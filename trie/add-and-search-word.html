<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Add and Search Word - Trie Visualization</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        body { background-color: #0f1729; color: #e2e8f0; }
        .trie-node { transition: all 0.3s ease-in-out; background-color: #1e293b; border: 2px solid #3b82f6; }
        .trie-node.highlight { background-color: #ea580c; border-color: #fb923c; }
        .trie-node.wildcard { background-color: #f59e0b; border-color: #fbbf24; }
        .trie-node.found { background-color: #16a34a; border-color: #22c55e; }
        .trie-node.end-word { background-color: #8b5cf6; border-color: #a78bfa; }
        .trie-edge { stroke: #3b82f6; stroke-width: 2; transition: all 0.3s ease-in-out; }
        .trie-edge.active { stroke: #ea580c; stroke-width: 4; }
        .card { background-color: #1e293b; border: 1px solid #2d3748; }
        pre { background-color: #0f172a !important; border: 1px solid #2d3748; }
        input { background-color: #1e293b !important; border-color: #3b82f6 !important; color: #e2e8f0 !important; }
        input::placeholder { color: #64748b !important; }
        .code-line { font-family: monospace; padding: 2px 8px; border-radius: 4px; }
        .code-line.active { background-color: #374151; color: #10b981; }
        .wildcard-char { color: #f59e0b; font-weight: bold; }
    </style>
</head>
<body class="min-h-screen p-8">
    <div class="max-w-6xl mx-auto">
        <h1 class="text-3xl font-bold mb-6 text-blue-400">Add and Search Word - Design Data Structure</h1>
        
        <!-- Problem Statement -->
        <div class="card p-6 rounded-lg shadow-lg mb-6">
            <h2 class="text-xl font-semibold mb-4 text-blue-400">Problem Statement</h2>
            <p class="text-gray-300">
                Design a data structure that supports adding new words and finding if a string matches any previously added string. Implement the WordDictionary class with addWord() and search() methods. The search() method can search for a literal word or a regular expression string containing '.' where '.' can represent any letter.<br><br>
                <strong>Example:</strong><br>
                addWord("bad")<br>
                addWord("dad")<br>
                addWord("mad")<br>
                search("pad") → false<br>
                search("bad") → true<br>
                search(".ad") → true<br>
                search("b..") → true<br><br>
                <strong>Difficulty:</strong> Medium<br>
                <strong>Pattern:</strong> Trie + DFS
            </p>
        </div>

        <!-- Operations -->
        <div class="card p-6 rounded-lg shadow-lg mb-6">
            <h2 class="text-xl font-semibold mb-4 text-blue-400">Operations</h2>
            <div class="grid grid-cols-1 md:grid-cols-2 gap-4 mb-4">
                <div>
                    <label class="block text-sm font-medium mb-2 text-gray-300">Add Word</label>
                    <input type="text" id="addInput" placeholder="bad" class="border p-2 rounded w-full mb-2">
                    <button onclick="addWord()" class="bg-green-600 text-white px-4 py-2 rounded hover:bg-green-700 w-full">Add Word</button>
                </div>
                <div>
                    <label class="block text-sm font-medium mb-2 text-gray-300">Search Word (use '.' for wildcard)</label>
                    <input type="text" id="searchInput" placeholder=".ad" class="border p-2 rounded w-full mb-2">
                    <button onclick="searchWord()" class="bg-blue-600 text-white px-4 py-2 rounded hover:bg-blue-700 w-full">Search</button>
                </div>
            </div>
            <div class="flex gap-4 mb-4">
                <button onclick="clearTrie()" class="bg-red-600 text-white px-4 py-2 rounded hover:bg-red-700">Clear</button>
                <button onclick="loadExample()" class="bg-yellow-600 text-white px-4 py-2 rounded hover:bg-yellow-700">Load Example</button>
            </div>
            <div class="bg-gray-800 p-3 rounded">
                <p class="text-sm text-gray-300">
                    <span class="wildcard-char">Tip:</span> Use '.' as a wildcard character that matches any single letter.
                    Examples: "b.d" matches "bad", "bed", "bid", etc.
                </p>
            </div>
        </div>

        <!-- Controls -->
        <div class="card p-6 rounded-lg shadow-lg mb-6">
            <div class="flex gap-4 justify-center mb-4">
                <button id="prevBtn" onclick="prev()" class="bg-gray-700 text-white px-4 py-2 rounded hover:bg-gray-600">Previous</button>
                <button id="playBtn" onclick="togglePlay()" class="bg-green-600 text-white px-4 py-2 rounded hover:bg-green-700">Play</button>
                <button id="nextBtn" onclick="next()" class="bg-gray-700 text-white px-4 py-2 rounded hover:bg-gray-600">Next</button>
            </div>
            <div class="flex justify-center">
                <input type="range" min="1" max="100" value="50" class="w-40" id="speedSlider">
                <span class="ml-2" id="speedValue">50%</span>
            </div>
        </div>

        <!-- Visualization -->
        <div class="card p-6 rounded-lg shadow-lg mb-6">
            <h2 class="text-xl font-semibold mb-4 text-blue-400">Trie Visualization</h2>
            <svg id="trieVisualization" width="100%" height="400" class="border border-gray-600 rounded"></svg>
            <div class="mt-4">
                <h3 class="font-semibold mb-2 text-gray-300">Current Operation:</h3>
                <div id="currentOperation" class="text-lg font-mono text-blue-400">Ready for operations</div>
            </div>
            <div id="explanation" class="text-gray-300 mt-4">Start by adding words or searching with wildcards</div>
            <div id="result" class="text-lg font-mono text-green-400 mt-2"></div>
        </div>

        <!-- Algorithm Details -->
        <div class="card p-6 rounded-lg shadow-lg">
            <h2 class="text-xl font-semibold mb-4 text-blue-400">Algorithm Details</h2>
            <div class="space-y-4">
                <div>
                    <h3 class="font-semibold mb-2">Time Complexity</h3>
                    <p class="text-gray-300">
                        • addWord: O(m) where m is word length<br>
                        • search (no wildcards): O(m)<br>
                        • search (with wildcards): O(n) worst case, where n is total nodes
                    </p>
                </div>
                <div>
                    <h3 class="font-semibold mb-2">Space Complexity</h3>
                    <p class="text-gray-300">O(ALPHABET_SIZE × N × M) for trie storage</p>
                </div>
                <div>
                    <h3 class="font-semibold mb-2">Wildcard Handling</h3>
                    <p class="text-gray-300">
                        1. Normal characters: Follow exact path in trie<br>
                        2. Wildcard '.': Try all possible children at current level<br>
                        3. Use DFS/recursion to handle multiple wildcards<br>
                        4. Backtrack when path doesn't lead to valid word
                    </p>
                </div>
            </div>
        </div>
    </div>

    <script>
        class TrieNode {
            constructor() {
                this.children = {};
                this.isEndOfWord = false;
                this.x = 0;
                this.y = 0;
                this.id = Math.random().toString(36).substr(2, 9);
            }
        }

        class WordDictionary {
            constructor() {
                this.root = new TrieNode();
                this.steps = [];
                this.currentStep = 0;
                this.isPlaying = false;
            }

            addWord(word) {
                this.steps = [];
                this.steps.push({
                    type: 'start',
                    operation: 'addWord',
                    word: word,
                    explanation: `Adding word: "${word}"`
                });

                let current = this.root;
                let path = [this.root];

                for (let i = 0; i < word.length; i++) {
                    const char = word[i];
                    
                    this.steps.push({
                        type: 'traverse',
                        operation: 'addWord',
                        word: word,
                        currentChar: char,
                        charIndex: i,
                        currentNode: current,
                        path: [...path],
                        explanation: `Processing character '${char}' at position ${i}`
                    });

                    if (!current.children[char]) {
                        current.children[char] = new TrieNode();
                        this.steps.push({
                            type: 'create',
                            operation: 'addWord',
                            word: word,
                            currentChar: char,
                            charIndex: i,
                            newNode: current.children[char],
                            parent: current,
                            path: [...path],
                            explanation: `Creating new node for character '${char}'`
                        });
                    }
                    
                    current = current.children[char];
                    path.push(current);
                }

                current.isEndOfWord = true;
                this.steps.push({
                    type: 'complete',
                    operation: 'addWord',
                    word: word,
                    finalNode: current,
                    path: [...path],
                    explanation: `Successfully added word "${word}"`
                });

                this.currentStep = 0;
                this.updateVisualization();
            }

            search(word) {
                this.steps = [];
                this.steps.push({
                    type: 'start',
                    operation: 'search',
                    word: word,
                    explanation: `Searching for pattern: "${word}" (wildcards shown in yellow)`
                });

                const result = this.dfs(word, 0, this.root, [this.root]);
                
                this.steps.push({
                    type: 'result',
                    operation: 'search',
                    word: word,
                    result: result,
                    explanation: result ? 
                        `Pattern "${word}" found in the dictionary!` : 
                        `Pattern "${word}" not found in the dictionary`
                });

                this.currentStep = 0;
                this.updateVisualization();
                return result;
            }

            dfs(word, index, node, path) {
                if (index === word.length) {
                    const found = node.isEndOfWord;
                    this.steps.push({
                        type: 'check_end',
                        operation: 'search',
                        word: word,
                        currentNode: node,
                        path: [...path],
                        result: found,
                        explanation: found ? 
                            'Reached end of pattern and found complete word!' :
                            'Reached end of pattern but not a complete word'
                    });
                    return found;
                }

                const char = word[index];
                
                if (char === '.') {
                    this.steps.push({
                        type: 'wildcard',
                        operation: 'search',
                        word: word,
                        currentChar: char,
                        charIndex: index,
                        currentNode: node,
                        path: [...path],
                        explanation: `Wildcard '.' at position ${index} - trying all possible characters`
                    });

                    // Try all possible children for wildcard
                    for (let childChar in node.children) {
                        this.steps.push({
                            type: 'try_wildcard',
                            operation: 'search',
                            word: word,
                            currentChar: childChar,
                            charIndex: index,
                            currentNode: node,
                            path: [...path],
                            explanation: `Trying '${childChar}' for wildcard at position ${index}`
                        });

                        const child = node.children[childChar];
                        if (this.dfs(word, index + 1, child, [...path, child])) {
                            return true;
                        }

                        this.steps.push({
                            type: 'backtrack_wildcard',
                            operation: 'search',
                            word: word,
                            currentChar: childChar,
                            charIndex: index,
                            currentNode: node,
                            path: [...path],
                            explanation: `'${childChar}' didn't work, backtracking...`
                        });
                    }
                    return false;
                } else {
                    this.steps.push({
                        type: 'traverse',
                        operation: 'search',
                        word: word,
                        currentChar: char,
                        charIndex: index,
                        currentNode: node,
                        path: [...path],
                        explanation: `Looking for exact character '${char}' at position ${index}`
                    });

                    if (!node.children[char]) {
                        this.steps.push({
                            type: 'not_found',
                            operation: 'search',
                            word: word,
                            currentChar: char,
                            charIndex: index,
                            currentNode: node,
                            path: [...path],
                            explanation: `Character '${char}' not found at position ${index}`
                        });
                        return false;
                    }

                    const child = node.children[char];
                    return this.dfs(word, index + 1, child, [...path, child]);
                }
            }

            updateVisualization() {
                this.calculatePositions();
                this.drawTrie();
                this.highlightCurrentStep();
            }

            calculatePositions() {
                const layers = this.getTrieLayers();
                const width = 800, height = 400;
                const layerHeight = height / (layers.length + 1);

                for (let i = 0; i < layers.length; i++) {
                    const layer = layers[i];
                    const layerWidth = width / (layer.length + 1);
                    for (let j = 0; j < layer.length; j++) {
                        layer[j].x = (j + 1) * layerWidth;
                        layer[j].y = (i + 1) * layerHeight;
                    }
                }
            }

            getTrieLayers() {
                const layers = [];
                const queue = [{node: this.root, level: 0}];
                
                while (queue.length > 0) {
                    const {node, level} = queue.shift();
                    if (!layers[level]) layers[level] = [];
                    layers[level].push(node);
                    
                    Object.values(node.children).forEach(child => {
                        queue.push({node: child, level: level + 1});
                    });
                }
                return layers;
            }

            drawTrie() {
                const svg = document.getElementById('trieVisualization');
                svg.innerHTML = '';
                this.drawTrieRecursive(this.root, svg, null, '');
            }

            drawTrieRecursive(node, svg, parent, edgeLabel) {
                if (parent) {
                    const line = document.createElementNS('http://www.w3.org/2000/svg', 'line');
                    line.setAttribute('x1', parent.x);
                    line.setAttribute('y1', parent.y);
                    line.setAttribute('x2', node.x);
                    line.setAttribute('y2', node.y);
                    line.setAttribute('class', 'trie-edge');
                    line.setAttribute('id', `edge-${parent.id}-${node.id}`);
                    svg.appendChild(line);

                    const text = document.createElementNS('http://www.w3.org/2000/svg', 'text');
                    text.setAttribute('x', (parent.x + node.x) / 2);
                    text.setAttribute('y', (parent.y + node.y) / 2 - 5);
                    text.setAttribute('fill', '#e2e8f0');
                    text.setAttribute('font-size', '14');
                    text.setAttribute('text-anchor', 'middle');
                    text.textContent = edgeLabel;
                    svg.appendChild(text);
                }

                const circle = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
                circle.setAttribute('cx', node.x);
                circle.setAttribute('cy', node.y);
                circle.setAttribute('r', node.isEndOfWord ? '20' : '15');
                circle.setAttribute('class', `trie-node ${node.isEndOfWord ? 'end-word' : ''}`);
                circle.setAttribute('id', `node-${node.id}`);
                svg.appendChild(circle);

                if (node.isEndOfWord) {
                    const text = document.createElementNS('http://www.w3.org/2000/svg', 'text');
                    text.setAttribute('x', node.x);
                    text.setAttribute('y', node.y + 5);
                    text.setAttribute('fill', '#ffffff');
                    text.setAttribute('font-size', '12');
                    text.setAttribute('text-anchor', 'middle');
                    text.textContent = '✓';
                    svg.appendChild(text);
                }

                Object.entries(node.children).forEach(([char, child]) => {
                    this.drawTrieRecursive(child, svg, node, char);
                });
            }

            highlightCurrentStep() {
                // Reset highlights
                document.querySelectorAll('.trie-node').forEach(node => {
                    node.classList.remove('highlight', 'found', 'wildcard');
                });
                document.querySelectorAll('.trie-edge').forEach(edge => {
                    edge.classList.remove('active');
                });

                if (this.steps.length === 0 || this.currentStep >= this.steps.length) return;

                const step = this.steps[this.currentStep];
                
                document.getElementById('explanation').textContent = step.explanation;
                document.getElementById('currentOperation').textContent = 
                    `${step.operation}("${step.word}") - Step ${this.currentStep + 1}/${this.steps.length}`;

                // Highlight current path
                if (step.path) {
                    step.path.forEach(node => {
                        const nodeElement = document.getElementById(`node-${node.id}`);
                        if (nodeElement) {
                            if (step.type === 'wildcard' || step.type === 'try_wildcard') {
                                nodeElement.classList.add('wildcard');
                            } else {
                                nodeElement.classList.add('highlight');
                            }
                        }
                    });

                    // Highlight edges in path
                    for (let i = 1; i < step.path.length; i++) {
                        const edgeElement = document.getElementById(`edge-${step.path[i-1].id}-${step.path[i].id}`);
                        if (edgeElement) {
                            edgeElement.classList.add('active');
                        }
                    }
                }

                // Show result
                if (step.result !== undefined) {
                    document.getElementById('result').textContent = 
                        `${step.operation}("${step.word}") = ${step.result}`;
                    
                    if (step.currentNode) {
                        const nodeElement = document.getElementById(`node-${step.currentNode.id}`);
                        if (nodeElement) {
                            nodeElement.classList.add('found');
                        }
                    }
                }
            }
        }

        let wordDict = new WordDictionary();

        function addWord() {
            const word = document.getElementById('addInput').value.trim().toLowerCase();
            if (word) {
                wordDict.addWord(word);
                document.getElementById('addInput').value = '';
            }
        }

        function searchWord() {
            const word = document.getElementById('searchInput').value.trim().toLowerCase();
            if (word) {
                wordDict.search(word);
                document.getElementById('searchInput').value = '';
            }
        }

        function clearTrie() {
            wordDict = new WordDictionary();
            wordDict.updateVisualization();
            document.getElementById('result').textContent = '';
            document.getElementById('explanation').textContent = 'Dictionary cleared. Start by adding words.';
        }

        function loadExample() {
            clearTrie();
            ['bad', 'dad', 'mad', 'bed', 'bat', 'cat'].forEach(word => {
                wordDict.addWord(word);
            });
            document.getElementById('result').textContent = 'Loaded example: bad, dad, mad, bed, bat, cat';
        }

        function next() {
            if (wordDict.currentStep < wordDict.steps.length - 1) {
                wordDict.currentStep++;
                wordDict.highlightCurrentStep();
            }
        }

        function prev() {
            if (wordDict.currentStep > 0) {
                wordDict.currentStep--;
                wordDict.highlightCurrentStep();
            }
        }

        function togglePlay() {
            if (wordDict.currentStep < wordDict.steps.length - 1) {
                next();
            }
        }

        document.getElementById('speedSlider').addEventListener('input', function() {
            document.getElementById('speedValue').textContent = this.value + '%';
        });

        // Initialize
        wordDict.updateVisualization();
    </script>
</body>
</html>