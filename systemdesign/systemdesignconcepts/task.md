Load Balancing - Distributing traffic across multiple servers

Caching - Storing frequently accessed data for faster retrieval

Database Concepts (SQL vs NoSQL) - Choosing the right database type

Horizontal vs Vertical Scaling - Adding more machines vs upgrading existing ones

Data Partitioning (Sharding) - Splitting datasets across multiple servers

Database Replication - Creating copies of data for availability

CAP Theorem - Consistency, Availability, Partition tolerance trade-offs

Consistency Patterns - Strong, eventual, and causal consistency

Rate Limiting - Controlling request frequency to prevent abuse

API Gateway - Single entry point for microservices routing

Microservices Architecture - Breaking systems into small, independent services

Distributed Messaging Systems - Asynchronous communication via queues

Forward Proxy vs Reverse Proxy - Client-side vs server-side proxies

Content Delivery Network (CDN) - Geographic content distribution

Domain Name System (DNS) - Translating domain names to IP addresses

Long Polling vs WebSockets - Real-time communication methods

Latency vs Throughput - Response time vs request handling capacity

Availability vs Reliability - Uptime vs correct functionality

Database Indexing - Data structures for faster queries

Heartbeat Mechanisms - Monitoring system component health

Checksum - Ensuring data integrity during transmission

Fault Tolerance - Handling failures gracefully

Health Checks & Auto-Recovery - Detecting and restarting failed services

Distributed File Systems - Managing files across multiple servers

Full-Text Search - Efficient document search and retrieval

Distributed Coordination Services - Managing synchronization (ZooKeeper)

Notification Systems - Real-time alerts and updates

Consistent Hashing - Distributing data with minimal redistribution

Authentication and Authorization - User verification and permissions

Security Monitoring - Infrastructure and application security

Circuit Breaker Pattern - Preventing cascade failures

Bulkhead Pattern - Isolating critical resources

Retry Mechanisms - Handling transient failures

Idempotency - Safe request retries

Event Sourcing - Storing state changes as events

Connection Pooling - Reusing database connections

Lazy Loading - Loading data only when needed

Prefetching - Loading data in advance

Compression - Reducing data transfer size

Pagination - Breaking large datasets into chunks